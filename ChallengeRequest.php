<?php

/**
 * Class ChallengeRequest
 *
 * Handles database queries corresponding to challenge related requests. Allows the user to create challenges,
 * modify their status (accept, decline, cancel) and finally post a result.
 */
class ChallengeRequest {

    /* The connection object. */
    private $connection;

    /**
     * Obtains a mysqli connection object via the Connection class.
     */
    function __construct() {
        require_once dirname(__FILE__) . "/Connection.php";
        $tennisDatabase = new Connection();
        $this->connection = $tennisDatabase->connect();
    }

    /**
     * @param $time String provided in UNIX time (seconds) makes for easier conversion for DB storage.
     * Create an entry in the challenge table containing challenge metadata.
     * @return bool Success status.
     */
    function createChallenge($clubName, $date, $time): bool {
        /* Format time for database storage */
        $date = intval($date);
        date_default_timezone_set("Europe/London");
        $mysqlDate = date("Y-m-d", $date);

        /* Prepare and execute statement. */
        $statementChallenge = $this->connection->prepare
        (
            "INSERT INTO challenge (clubid, date, time) VALUES ((SELECT clubid from club WHERE name = ?), ?, ?)"
        );
        $statementChallenge->bind_param("sss", $clubName, $mysqlDate, $time);
        if ($statementChallenge->execute()) {
            return true;
        }
        return false;
    }

    /**
     * Sets the accepted status for a given challenge ID to true.
     */
    function acceptChallenge($challengeID): bool {
        $statementAcceptChallenge = $this->connection->prepare
        (
            "UPDATE challenge SET accepted = 1 WHERE challengeid = ?"
        );
        $statementAcceptChallenge->bind_param("i", $challengeID);
        if ($statementAcceptChallenge->execute()) {
            return true;
        }
        return false;
    }

    /**
     * Shares functionality for both cancelling and declining a challenge. Deletes the challenge
     * with the associated ID from both the challenge and player_challenge tables.
     */
    function cancelChallenge($challengeID): bool {
        /* Player challenge statement. */
        $statementPlayerChallenge = $this->connection->prepare
        (
            "DELETE FROM player_challenge WHERE challengeid = ?"
        );
        $statementPlayerChallenge->bind_param("i", $challengeID);

        /* Challenge statement. */
        $statementChallenge = $this->connection->prepare
        (
            "DELETE FROM challenge WHERE challengeid = ?"
        );

        /* Execute statements. */
        $statementChallenge->bind_param("i", $challengeID);
        if (!$statementPlayerChallenge->execute()) {
            return false;
        }
        if (!$statementChallenge->execute()) {
            return false;
        }
        return true;
    }

    /**
     * Upon creation of a challenge, returns the newly auto-generated challenge ID. This is further used as
     * a reference in the player_challenge table as part of a compound key. The limitation of this function
     * is that it returns the latest entry, which will run into concurrency issues if the app gets busy.
     */
    function getChallengeID(): string {
        /* Prepare and execute statement. */
        $statementGetID = $this->connection->prepare
        (
            "SELECT challengeid FROM challenge ORDER BY challengeid DESC LIMIT 1"
        );
        $statementGetID->bind_result($challengeID);
        $statementGetID->execute();
        $statementGetID->fetch();
        $statementGetID->close();
        $challengeID = strval($challengeID); // Returned in string format as it is fed back as a parameter.
        return $challengeID;
    }

    /**
     * @param int $challengeID The autogenerated challenge ID.
     * Use the autogenerated challenge ID to create player_challenge entries for both players.
     * @return bool Error status.
     */
    function createPlayerChallenge($challengeID, $playerID, $opponentID): bool {
        $challengeID = intval($challengeID);

        /* Prepare and execute the user entry, where 1 indicates that they initiated the challenge from their client. */
        $playerID = intval($playerID);
        $statementUser = $this->connection->prepare
        (
            "INSERT INTO player_challenge (challengeid, playerid, didinitiate) VALUES (?, ?, 1)"
        );
        $statementUser->bind_param("ii", $challengeID, $playerID);
        if (!$statementUser->execute()) {
            return false;
        }
        $statementUser->close();

        /* Prepare and execute the opponent entry, 0 indicates that they are recieving the challenge. */
        $opponentID = intval($opponentID);
        $statementOpponent = $this->connection->prepare
        (
            "INSERT INTO player_challenge (challengeid, playerid, didinitiate) VALUES (?, ?, 0)"
        );
        $statementOpponent->bind_param("ii", $challengeID, $opponentID);
        if (!$statementOpponent->execute()) {
            return false;
        }
        $statementOpponent->close();

        /* Both statements executed successfully. */
        return true;

    }

    /**
     * Obtain all challenges for a user, preceded by the depreciated getChallengesData() method.
     *
     *
     * First obtains a list of challenge ID's and initiation status' from the
     * player_challenge table, and inserts these into an array of keypair values. Using the challenge ID's,
     * query for challenge metadata as well as opponent data. As we iterate, append data from the initial array
     * (used to identify challenge ID's), and the fetched data to the array for return. This results in final
     * array being correctly formatted for JSON encoding.
     */
    function getChallenges($playerID): array {
        /* Construct a list of challenge ID's an initiation status'.
        -1 indicates that a result has not been posted and the match
        not yet played. */
        $statementGetIDList = $this->connection->prepare
        (
            "SELECT challengeid, didinitiate FROM player_challenge WHERE playerid = ? AND didwin = -1"
        );

        /* Prepare and execute statement. */
        $playerID = intval($playerID);
        $statementGetIDList->bind_param("i", $playerID);
        $statementGetIDList->execute();
        $statementGetIDList->bind_result($challengeID, $didInitiate);
        $challengeList = array();
        while ($statementGetIDList->fetch()) {
            $locatedChallenge = array();
            $locatedChallenge["challengeid"] = $challengeID;
            $locatedChallenge["didinitiate"] = $didInitiate;
            array_push($challengeList, $locatedChallenge);
        }
        $statementGetIDList->close();

        /* For each identified challenge, fetch relevant data. */
        $challenges = array();  // The final challenges array to be returned.
        foreach ($challengeList as $c) {
            /* Statement to fetch opponent data, != playerID refers to the opponent. */
            $statementGetOpponent = $this->connection->prepare
            (
                "SELECT playerid, fname, lname, elo, winstreak, hotstreak, matchesplayed, wins, losses, highestelo, clubchamp 
                        FROM player WHERE playerid = (SELECT playerid FROM player_challenge WHERE challengeid = ? AND playerid != ?)"
            );

            /* Statement to fetch challenge metadata. */
            $statementGetChallengeData = $this->connection->prepare
            (
                "SELECT date, time, (SELECT name FROM club 
                        WHERE challenge.clubid = club.clubid ), accepted FROM challenge WHERE challengeid = ?"
            );

            /* Prepare and execute the opponent data statement. */
            $statementGetOpponent->bind_param("ii", $c["challengeid"], $playerID);
            $statementGetOpponent->execute();
            $statementGetOpponent->bind_result($opponentID, $fname, $lname, $elo, $winStreak, $hotStreak, $matchesPlayed, $numWins, $numLosses, $highestElo, $clubChamp);
            $statementGetOpponent->fetch();
            $statementGetOpponent->close();

            /* Prepare and execute the challenge data statement. */
            $statementGetChallengeData->bind_param("i", $c["challengeid"]);
            $statementGetChallengeData->execute();
            $statementGetChallengeData->bind_result($date, $time, $location, $accepted);
            $statementGetChallengeData->fetch();
            $statementGetChallengeData->close();

            $challenge = array();   // Array to hold a single challenge.

            /* Append fetched data to the challenges array. */
            $challenge["challengeid"] = $c["challengeid"];
            $challenge["didinitiate"] = $c["didinitiate"];
            $challenge["opponentid"] = $opponentID;
            $challenge["fname"] = $fname;
            $challenge["lname"] = $lname;
            $challenge["elo"] = $elo;
            $challenge["winstreak"] = $winStreak;
            $challenge["hotstreak"] = $hotStreak;
            $challenge["matchesplayed"] = $matchesPlayed;
            $challenge["wins"] = $numWins;
            $challenge["losses"] = $numLosses;
            $challenge["highestelo"] = $highestElo;
            $challenge["clubchamp"] = $clubChamp;
            $challenge["date"] = $date;
            $challenge["time"] = $time;
            $challenge["location"] = $location;
            $challenge["accepted"] = $accepted;
            $challenge["achieved"] = (new PlayerRequest)->getUserAchievements($opponentID); // Fetch user achievement data.
            array_push($challenges, $challenge);
        }
        return $challenges;
    }

    /**
     * Updates the database with fields relating to a reported result.
     */
    function postResult($challengeID, $winnerID, $loserID, $score, $winnerElo, $loserElo, $newHighestElo, $hotStreak) {
        $challengeID = intval($challengeID);
        $winnerID = intval($winnerID);
        $loserID = intval($loserID);
        $winnerElo = intval($winnerElo);
        $loserElo = intval($loserElo);
        $newHighestElo = intval($newHighestElo);
        $hotStreak = intval($hotStreak);

        /* Identify the current highest rated player at the winners club and check if the user
        has overtaken them. If they have, unset the club champion status for the current holder. */
        $currentClubMax = $this->getClubMaxElo($winnerID);
        if ($winnerElo >= $currentClubMax) {
            $clubChampion = 1;
            $this->removeChampionStatus($currentClubMax);
        } else {
            $clubChampion = 0;
        }

        /* Check if the loser has been dethroned (lost their champion status). */
        $this->checkDethroned($loserID, $loserElo);

        /* Update the score in the challenges table. */
        $statementUpdateScore = $this->connection->prepare
        (
            "UPDATE challenge SET score = ? WHERE challengeid = ?"
        );
        $statementUpdateScore->bind_param("si", $score, $challengeID);
        if (!$statementUpdateScore->execute()) {
            return false;
        }
        $statementUpdateScore->close();

        /* Update the winner in the player_challenges table. */
        $statementUpdateWinner = $this->connection->prepare
        (
            "UPDATE player_challenge SET didwin = 1 WHERE challengeid = ? AND playerid = ?"
        );
        $statementUpdateWinner->bind_param("ii", $challengeID, $winnerID);
        if (!$statementUpdateWinner->execute()) {
            return false;
        }
        $statementUpdateWinner->close();

        /* Update the loser in the player_challenges table. */
        $statementUpdateLoser = $this->connection->prepare
        (
            "UPDATE player_challenge SET didwin = 0 WHERE challengeid = ? AND playerid = ?"
        );
        $statementUpdateLoser->bind_param("ii", $challengeID, $loserID);
        if (!$statementUpdateLoser->execute()) {
            return false;
        }
        $statementUpdateLoser->close();

        /* Update the player data for the winner. */
        $statementWinnerPlayer = $this->connection->prepare
        (
            "UPDATE player SET elo = ?, winstreak = winstreak + 1, hotstreak = ?, 
                  matchesplayed = matchesplayed + 1, wins = wins + 1, highestelo = ?, clubchamp = ? WHERE playerid = ?"
        );
        $statementWinnerPlayer->bind_param("iiiii", $winnerElo, $hotStreak, $newHighestElo, $clubChampion, $winnerID);
        if (!$statementWinnerPlayer->execute()) {
            return false;
        }
        $statementWinnerPlayer->close();

        /* Update the player data for the loser. */
        $statementLoserPlayer = $this->connection->prepare
        (
            "UPDATE player SET elo = ?, winstreak = 0, hotstreak = 0, 
                  matchesplayed = matchesplayed + 1, losses = losses + 1 WHERE playerid = ?"
        );
        $statementLoserPlayer->bind_param("ii", $loserElo, $loserID);
        if (!$statementLoserPlayer->execute()) {
            return false;
        }
        $statementLoserPlayer->close();

        /* Statement executed successfully. */
        return true;
    }

    /**
     * Identify the current highest Elo at a given users club.
     */
    function getClubMaxElo($playerID)
    {
        /* Fetch every players Elo from the users club. */
        $statementGetElos = $this->connection->prepare
        (
            "SELECT playerid, elo FROM player WHERE clubid = 
                    (SELECT clubid FROM player WHERE playerid = ?)"
        );
        $statementGetElos->bind_param("i", $playerID);
        $statementGetElos->execute();
        $statementGetElos->bind_result($userID, $elo);
        $elos = array();
        /* Don't append the users elo. */
        while ($statementGetElos->fetch()) {
            if ($userID != $playerID) {
                array_push($elos, $elo);
            }
        }
        $statementGetElos->close();
        return max($elos);  // Return the highest value.
    }

    /**
     * Unset the club champion status of the current club champion.
     */
    function removeChampionStatus($elo)
    {
        $statementRemoveChampion = $this->connection->prepare
        (
            "UPDATE player SET clubchamp = 0 WHERE elo = ?"
        );
        $statementRemoveChampion->bind_param("i", $elo);
        $statementRemoveChampion->execute();
        $statementRemoveChampion->close();
    }

    /**
     * Check if a losing player has lost their champion status. If so, update the new champion status
     * in the database.
     * @param int $loserID The losers ID.
     * @param int $elo The losers Elo.
     */
    function checkDethroned($loserID, $elo) {
        /* Check if they are the club champion. */
        $statementGetChamp = $this->connection->prepare
        (
            "SELECT clubchamp FROM player WHERE playerid = ?"
        );
        $statementGetChamp->bind_param("i", $loserID);
        $statementGetChamp->execute();
        $statementGetChamp->bind_result($clubChamp);
        $statementGetChamp->fetch();
        $statementGetChamp->close();
        if ($clubChamp == 1) {
            $currentClubMax = $this->getClubMaxElo($loserID);
            /* If there is now a player at the club with a higher rating, remove clubchamp status. */
            if ($currentClubMax >= $elo) {
                $statementDethrone = $this->connection->prepare
                (
                    "UPDATE player SET clubchamp = 0 WHERE playerid = ?"
                );
                $statementDethrone->bind_param("i", $loserID);
                $statementDethrone->execute();
                $statementDethrone->close();

                /* Crown the new club champion. */
                $statementThrone = $this->connection->prepare
                (
                    "UPDATE player SET clubchamp = 1 WHERE elo = ?"
                );
                $statementThrone->bind_param("i", $currentClubMax);
                $statementThrone->execute();
                $statementThrone->close();
            }
        }
    }
}